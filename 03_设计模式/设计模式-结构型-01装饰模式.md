## 装饰模式

装饰模式也称为包装模式；

![](../article_res/design_pattern/装饰模式.png)

1. 使用一种对客户端透明的方式来动态扩展对象的功能，也是继承关系的一种替代方案之一。
2. 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更为灵活。




## 示例

![](../article_res/design_pattern/decorator_p2.png)


```java
public class Main {
    public static void main(String[] args) {
        Person boy = new Boy();

        System.out.println("----------- 穿便宜的衣服 -------------");
        CheapCloth cheapCloth = new CheapCloth(boy);
        cheapCloth.dressed();

        System.out.println("\n----------- 穿贵的衣服 -------------");
        ExpensiveCloth expensiveCloth = new ExpensiveCloth(boy);
        expensiveCloth.dressed();
    }
}
```

```java
public class Boy extends Person {
    @Override
    public void dressed() {
        System.out.println("穿上内裤");
    }
}
```

```java
public class CheapCloth extends PersonCloth {
    public CheapCloth(Person person) {
        super(person);
    }

    private void dressShorts(){
        System.out.println("穿条短裤！");
    }

    @Override
    public void dressed() {
        super.dressed();
        dressShorts();
    }
}

```

```java
public class ExpensiveCloth extends PersonCloth{
    public ExpensiveCloth(Person person) {
        super(person);
    }

    private void dressShirt(){
        System.out.println("穿件短袖");
    }

    private void dressLeather(){
        System.out.println("穿件皮衣");
    }

    private void dressJean(){
        System.out.println("穿条牛仔裤");
    }

    @Override
    public void dressed() {
        super.dressed();
        dressShirt();
        dressLeather();
        dressJean();
    }
}

```

```java
public abstract class Person {
    public abstract void dressed();
}
```

```java
public abstract class PersonCloth extends Person {

    protected Person person;

    public PersonCloth(Person person) {
        this.person = person;
    }

    public void dressed(){
        person.dressed();
    }
}

```

输出结果：
```java
----------- 穿便宜的衣服 -------------
穿上内裤
穿条短裤！

----------- 穿贵的衣服 -------------
穿上内裤
穿件短袖
穿件皮衣
穿条牛仔裤
```