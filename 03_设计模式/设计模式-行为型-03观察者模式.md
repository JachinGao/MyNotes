## 一、定义

它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。
![observer](.\..\article_res\design_pattern\observer.png)

* Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
* ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
* Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
* ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。

## 二、具体实现

1. 抽象观察者

```java
public interface Observer {
    public void update(String message);
}
```

2. 具体观察者

```
public class WeChatUser implements Observer{
    private String name;

    public WeChatUser(String name) {
        this.name = name;
    }

    @Override
    public void update(String msg) {
        System.out.println(name+"-"+msg);
    }
}
```

3. 抽象被观察者

```java
public interface Subject {
    /**
     * 增加订阅者
     * @param observer
     */
    public void attach(Observer observer);
    /**
     * 删除订阅者
     * @param observer
     */
    public void detach(Observer observer);
    /**
     * 通知订阅者更新消息
     */
    public void notify(String message);
}
```

4. 具体被观察者

```java
public class SubscriptionSubject implements Subject {
    private final List<Observer> userList = new ArrayList<>();

    @Override
    public void attach(Observer observer) {
        userList.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        userList.remove(observer);
    }

    @Override
    public void notify(String message) {
        for (Observer observer : userList) {
            observer.update(message);
        }
    }
}
```

5. 段侧调用

```java
		SubscriptionSubject subject = new SubscriptionSubject();
        WeChatUser user1 = new WeChatUser("亚索");
        WeChatUser user2 = new WeChatUser("提莫");
        WeChatUser user3 = new WeChatUser("盖伦");

        subject.attach(user1);
        subject.attach(user2);
        subject.attach(user3);

        subject.notify("状态更新...");

//结果

亚索-状态更新...
提莫-状态更新...
盖伦-状态更新...
```

