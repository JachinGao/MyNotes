好的设计是：对扩展开放，对修改关闭；



## 根据模式的目的划分



#### 创建型模式，共五种：



* **01_单例模式**

  该类负责创建自己的对象，同时确保只有单个对象被创建。并提供了一种访问其唯一的对象的方式。实现方式有：懒汉式、饿汉式、静态内部类。

  

* **02_原型模式**

  用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同的新对象。因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，比直接new一个对象在性能上要好的多。

  实现方式是：1.实现cloneable接口，2.重写object类中的clone方法；

  深拷贝与浅拷贝：Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝。

  

* **03_工厂方法模式**

  解决简单工厂中if-else"的问题，**为每一个产品子类建立一个对应的工厂子类**，这些工厂子类实现同一个抽象工厂接口，由工厂子类决定要实例化具体的产品类。

  

* **04_抽象工厂模式**

  缩减工厂实现子类的数量，不必给每一个产品分配一个工厂类，可以将产品进行分组，每组中的不同产品由同一个工厂类的不同方法来创建。缺点是当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

  

* **05_建造者模式**

  当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，可以考虑使用构造者模式。建造者模式将一个复杂的对象的构建与它的表示分离，使得同样的构建过程中，可以创建不同的表示。
  
  android中dialog和notification中使用的都是建造者模式。



#### 常见问题

##### 1.  通过静态内部类实现单例模式的优点：

1. 不用 synchronized ，节省时间。 
2. 调用 getInstance() 的时候才会创建对象，不调用不创建，节省空间，这有点像懒汉式。

##### 2.  简单工厂、工厂方法、抽象工厂、Builder 模式的区别？

* 简单工厂模式：一个工厂方法创建不同类型的对象。
* 工厂方法模式：一个具体的工厂类负责创建一个具体对象类型。
* 抽象工厂模式：一个具体的工厂类负责创建一系列相关的对象。
* Builder 模式：对象的构建与表示分离，它更注重对象的创建过程。



**结构型模式**，共七种：

* 06_适配器模式

* 07_装饰器模式

* 08_代理模式

* 09_外观模式

* 10_桥接模式

* 11_组合模式

* 12_享元模式

  

**行为型模式**，共十一种：

* 13_策略模式
* 14_模板方法模式
* 15_观察者模式
* 16_迭代器模式
* 17_责任链模式
* 18_命令模式
* 19_备忘录模式
* 20_状态模式
* 21_访问者模式
* 22_中介者模式
* 23_解释器模式



## 根据模式的作用划分

根据模式的主要用于类上还是主要用户对象上来分，这种方式可分为类模式和对象模式两种。



### 1.2.1 **类模式**

用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时便确定下来了。如，工厂方法、（类）适配器、模板方法、解释器等4种类模式。

### 1.2.2 **对象模式**

用户处理对象之间关系的，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。



| **范围/目的** | **创建型模式**            | **结构型模式**                                  | **行为型模式**                                         |
| ------------- | ------------------------- | ----------------------------------------------- | :----------------------------------------------------- |
| **类模式**    | 工厂方法                  | （类）适配器                                    | 模板方法 解释器                                        |
| **对象模式**  | 单例 原型 抽象工厂 建造者 | 代理 （对象）适配器  桥接  装饰  外观 享元 组合 | 策略 命令 职责链 状态 观察者 中介者 迭代 访问者 备忘录 |