好的设计是：对扩展开放，对修改关闭；



## 根据模式的目的划分

**创建型模式**，共五种：

* **01_工厂方法模式**

  定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

* **02_抽象工厂模式**

  分离接口与实现，客户端使用抽象工厂来创建须要的对象，而客户端根部就不知道具体的实现是谁，客户端只是面向产品的接口而已，使其从具体的产品实现中解耦。

* 03_单例模式

* 04_建造者模式

* 05_原型模式

  

**结构型模式**，共七种：

* 06_适配器模式

* 07_装饰器模式

* 08_代理模式

* 09_外观模式

* 10_桥接模式

* 11_组合模式

* 12_享元模式

  

**行为型模式**，共十一种：

* 13_策略模式
* 14_模板方法模式
* 15_观察者模式
* 16_迭代器模式
* 17_责任链模式
* 18_命令模式
* 19_备忘录模式
* 20_状态模式
* 21_访问者模式
* 22_中介者模式
* 23_解释器模式



## 根据模式的作用划分

根据模式的主要用于类上还是主要用户对象上来分，这种方式可分为类模式和对象模式两种。



### 1.2.1 **类模式**

用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时便确定下来了。如，工厂方法、（类）适配器、模板方法、解释器等4种类模式。

### 1.2.2 **对象模式**

用户处理对象之间关系的，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。



| **范围/目的** | **创建型模式**            | **结构型模式**                                  | **行为型模式**                                         |
| ------------- | ------------------------- | ----------------------------------------------- | :----------------------------------------------------- |
| **类模式**    | 工厂方法                  | （类）适配器                                    | 模板方法 解释器                                        |
| **对象模式**  | 单例 原型 抽象工厂 建造者 | 代理 （对象）适配器  桥接  装饰  外观 享元 组合 | 策略 命令 职责链 状态 观察者 中介者 迭代 访问者 备忘录 |