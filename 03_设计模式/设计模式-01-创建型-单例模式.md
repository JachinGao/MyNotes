## 单例模式


 1. 构造函数私有化（使其不能通过new的方式创建对象）
 2. 通过静态方法返回单例类对象；
 3. 确保单例类的对象只有一个，尤其是在多线程下；
 4. 确保单例类对象在反序列化时不会重新构建对象；



### 饿汉式
优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。

 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。

```java
public class Singleton {
    private final static Singleton instance = new Singleton();

    // 也可通过静态代码块实现
//    static {
//        instance = new singleton.Singleton();
//    }


    private Singleton(){}

    public static Singleton getInstance(){
        return instance;
    }

    public void print(){
        System.out.println("method 1");
    }
}

```

### 懒汉式

1. 懒加载，调用时再加载；
2. 会出现线程不同步问题，使用sync关键字；
3. 每次调用都要进行同步，效率太太低，引入if（single ==null）判断的方式，双重检查；


```java
public class Singleton2 {
    private static Singleton2 singleton2;

    private Singleton2(){}

    public static Singleton2 getInstance(){
        if (singleton2==null){
            synchronized (Singleton2.class){
                if (singleton2==null){
                    singleton2 = new Singleton2();
                }
            }
        }
        return singleton2;
    }

    public void print(){
        System.out.println("method 2");
    }
}
```

### 静态内部类

类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

```java
public class Singleton3 {
    private Singleton3(){}

    private static class SingletonInstance{
        private static final Singleton3 sInstance = new Singleton3();
    }

    public static Singleton3 getInstance(){
        return SingletonInstance.sInstance;
    }

    public void print(){
        System.out.println("method 3");
    }
}

```